{"usr":{"include":{"sys":{"types.h":"#pragma once\n\ntypedef long ssize_t;\n\ntypedef int pid_t;\ntypedef long off_t;\n"},"ctype.h":"#pragma once\n\nint isdigit(int c);\nint isxdigit(int c);\nint isalpha(int c);\nint isalnum(int c);\nint isspace(int c);\n\nint tolower(int c);\nint toupper(int c);\n","fcntl.h":"#pragma once\n\n#define O_RDONLY  (0x000)\n#define O_WRONLY  (0x001)\n#define O_RDWR    (0x002)\n#define O_TRUNC   (0x100)\n#define O_CREAT   (0x200)\n#define O_APPEND  (0x400)\n\n#define S_IRUSR         (0400)\n#define S_IWUSR         (0200)\n#define S_IXUSR         (0100)\n#define S_IRGRP         (0040)\n#define S_IWGRP         (0020)\n#define S_IXGRP         (0010)\n#define S_IROTH         (0004)\n#define S_IWOTH         (0002)\n#define S_IXOTH         (0001)\n\nint open(const char *fn, int flag, ...);\n","math.h":"#pragma once\n\n#ifndef __NO_FLONUM\n#define M_PI      (3.14159265358979323846)\n#define M_E       (2.718281828459045)\n#define NAN       (0.0 / 0.0)\n#define HUGE_VAL  (1.0 / 0.0)\n\ndouble sin(double);\ndouble cos(double);\ndouble tan(double);\ndouble atan(double);\ndouble sqrt(double);\ndouble log(double x);\ndouble exp(double x);\ndouble pow(double base, double x);\ndouble fabs(double);\ndouble floor(double);\ndouble ceil(double x);\ndouble fmod(double x, double m);\ndouble frexp(double x, int *p);\n\nint isfinite(double x);\nint isnan(double x);\nint isinf(double x);\n#endif\n","stdarg.h":"#pragma once\n\ntypedef __builtin_va_list __gnuc_va_list;\ntypedef __gnuc_va_list va_list;\n\n#define va_start(v,l)   __builtin_va_start(v,l)\n#define va_end(v)       __builtin_va_end(v)\n#define va_arg(v,l)     __builtin_va_arg(v,l)\n#define va_copy(d,s)    __builtin_va_copy(d,s)\n","stdbool.h":"#pragma once\n\ntypedef int bool;\n#define false  (0)\n#define true   (1)\n","stddef.h":"#pragma once\n\n#ifndef NULL\n#define NULL  ((void*)0)\n#endif\n\n#define offsetof(S, mem)  ((size_t)&(((S *)0)->mem))\n\ntypedef unsigned long size_t;\n","stdint.h":"#pragma once\n\n#include \"stddef.h\"\n\ntypedef char  int8_t;\ntypedef short int16_t;\ntypedef int   int32_t;\ntypedef long  int64_t;\n\ntypedef unsigned char  uint8_t;\ntypedef unsigned short uint16_t;\ntypedef unsigned int   uint32_t;\ntypedef unsigned long  uint64_t;\n\ntypedef long intptr_t;\ntypedef size_t uintptr_t;\n","stdio.h":"#pragma once\n\n#include \"stdarg.h\"\n#include \"stddef.h\"\n\n#define EOF  (-1)\n\nenum {\n  SEEK_SET,  // 0\n  SEEK_CUR,  // 1\n  SEEK_END,  // 2\n};\n\ntypedef struct FILE FILE;\n\nextern FILE *stdin;\nextern FILE *stdout;\nextern FILE *stderr;\n\nFILE *fopen(const char *fileName, const char *mode);\nint fclose(FILE *fp);\nsize_t fwrite(const void *buffer, size_t size, size_t count, FILE *fp);\nsize_t fread(void *buffer, size_t size, size_t count, FILE *fp);\nint fseek(FILE *fp, long offset, int origin);\nlong ftell(FILE *fp);\nint remove(const char *fn);\n\nint fgetc(FILE *fp);\nint fputc(int c, FILE *fp);\nint getchar(void);\n\nint fprintf(FILE *fp, const char *fmt, ...);\nint printf(const char *fmt, ...);\nint sprintf(char *out, const char *fmt, ...);\nint snprintf(char *, size_t n, const char *, ...);\nint vfprintf(FILE *fp, const char *fmt, va_list ap);\nint vsnprintf(char *out, size_t n, const char *fmt_, va_list ap);\n\nvoid perror(const char *);\n\nint fileno(FILE *fp);\nFILE *tmpfile(void);\n","stdlib.h":"#pragma once\n\n#include \"stddef.h\"  // size_t\n\nint atoi(const char* s);\nvoid *malloc(size_t size);\nvoid free(void* ptr);\nvoid *realloc(void* ptr, size_t size);\nvoid *calloc(size_t size, size_t n);\n\nvoid exit(int code);\n\nlong strtol(const char *p, char **pp, int base);\nunsigned long strtoul(const char *p, char **pp, int base);\n\nvoid qsort(void *base, size_t nmemb, size_t size, int (*compare)(const void *, const void *));\n\n#ifndef __NO_FLONUM\ndouble strtod(const char* /*restrict*/ p, char ** /*restrict*/ pp);\ndouble drand48(void);\ndouble erand48(unsigned short xsubi[3]);\n#endif\n","string.h":"#pragma once\n\n#include <stddef.h>  // size_t\n\nsize_t strlen(const char *s);\nchar* strchr(const char *s, int c);\nchar* strrchr(const char *s, int c);\nchar *strstr(const char *s1, const char *s2);\nint strcmp(const char *p, const char *q);\nint strncmp(const char *p, const char *q, size_t n);\nchar* strcpy(char *s, const char *t);\nchar* strncpy(char *s, const char *t, size_t n);\n\nvoid* memcpy(void *dst, const void *src, size_t n);\nvoid* memmove(void*, const void*, size_t);\nvoid* memset(void* buf, int val, size_t size);\nint memcmp(const void *buf1, const void *buf2, size_t n);\n","unistd.h":"#pragma once\n\n#include \"stddef.h\"  // size_t\n#include \"stdint.h\"  // intptr_t\n#include \"sys/types.h\"  // ssize_t, pid_t, off_t\n\n#define STDIN_FILENO   (0)\n#define STDOUT_FILENO  (1)\n#define STDERR_FILENO  (2)\n\nvoid exit(int code);\nssize_t write(int fd, const void *str, size_t len);\nint close(int fd);\nssize_t read(int fd, void *buf, size_t size);\n\nchar *getcwd(char *buffer, size_t size);\n\npid_t fork(void);\nint pipe(int *);\nint dup(int);\nint execv(const char *, char *const[]);\nint execvp(const char *, char *const[]);\nint execve(const char *, char *const[], char *const[]);\noff_t lseek(int fd, off_t offset, int whence);\nint unlink(const char *pathname);\n\nint brk(void *addr);\nvoid *sbrk(intptr_t increment);\n\nint isatty(int fd);\n"},"lib":{"_file.h":"#pragma once\n\nstruct FILE {\n  int fd;\n};\n","lib.c":"#include \"ctype.h\"\n#include \"fcntl.h\"\n#include \"stdbool.h\"\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"unistd.h\"\n\n#include \"_file.h\"\n\nextern void *_brk(void *);\nextern int _tmpfile(void);\nextern int _getcwd(char *, size_t);\n\nsize_t strlen(const char *s) {\n  const char *p;\n  for (p = s; *p != '\\0'; ++p)\n    ;\n  return p - s;\n}\n\nchar *strchr(const char *s, int c) {\n  for (; *s != '\\0'; ++s)\n    if (*s == c)\n      return (char*)s;\n  return 0;\n}\n\nchar *strrchr(const char *s, int c) {\n  char *last = NULL;\n  for(; *s != '\\0'; ++s)\n    if(*s == c)\n      last = (char*)s;\n  return last;\n}\n\nchar *strstr(const char *s1, const char *s2) {\n  for  (size_t len = strlen(s2); *s1 != '\\0'; ++s1) {\n    if (strncmp(s1, s2, len) == 0)\n      return (char*)s1;\n  }\n  return NULL;\n}\n\nint strcmp(const char *p, const char *q) {\n  while (*p != '\\0' && *p == *q) {\n    ++p;\n    ++q;\n  }\n  return (int)*(unsigned char*)p - (int)*(unsigned char*)q;\n}\n\nint strncmp(const char *p, const char *q, size_t n) {\n  while (n > 0 && *p == *q && *p != '\\0')\n    n--, p++, q++;\n  return n == 0 ? 0 : (int)*(unsigned char*)p - (int)*(unsigned char*)q;\n}\n\nint strcasecmp(const char *p, const char *q) {\n  for (;; ++p, ++q) {\n    unsigned char c1 = *(unsigned char*)p;\n    unsigned char c2 = *(unsigned char*)q;\n    int d = (int)c1 - (int)c2;\n    if (d != 0)\n      return d;\n    if (c1 == 0)\n      break;\n  }\n  return 0;\n}\n\nint strncasecmp(const char *p, const char *q, size_t n) {\n  for (; n > 0; --n, ++p, ++q) {\n    int c1 = tolower(*(unsigned char*)p);\n    int c2 = tolower(*(unsigned char*)q);\n    int d = c1 - c2;\n    if (d != 0)\n      return d;\n    if (c1 == 0)\n      break;\n  }\n  return 0;\n}\n\nchar *strcpy(char *s, const char *t) {\n  char *os = s;\n  while ((*s++ = *t++) != '\\0')\n    ;\n  return os;\n}\n\nchar *strncpy(char *s, const char *t, size_t n) {\n  char *os = s;\n  for (; n > 0 && (*s++ = *t++) != '\\0'; --n)\n    ;\n  return os;\n}\n\nvoid *memcpy(void *dst, const void *src, size_t n) {\n  const char *s = src;\n  char *d = dst;\n  while (n-- > 0)\n    *d++ = *s++;\n  return dst;\n}\n\nvoid *memmove(void *dst, const void *src, size_t n) {\n  const char *s = src;\n  char *d = dst;\n  if (s < d && s + n > d) {\n    s += n;\n    d += n;\n    while (n-- > 0)\n      *--d = *--s;\n  } else {\n    while (n-- > 0)\n      *d++ = *s++;\n  }\n  return dst;\n}\n\nvoid *memset(void *buf, int val, size_t size) {\n  unsigned char *p = buf;\n  unsigned char v = val;\n  for (size_t i = 0; i < size; ++i)\n    *p++ = v;\n  return buf;\n}\n\nint memcmp(const void *buf1, const void *buf2, size_t n) {\n  const unsigned char *p = buf1;\n  const unsigned char *q = buf2;\n  int d;\n  for (size_t i = 0; i < n; ++i, ++p, ++q) {\n    d = (int)*(unsigned char*)p - (int)*(unsigned char*)q;\n    if (d != 0)\n      break;\n  }\n  return d;\n}\n\nstatic bool parse_sign(const char **pp) {\n  const char *p = *pp;\n  char c = *p;\n  bool negative = c == '-';\n  if (c == '+' || c == '-')\n    *pp = p + 1;\n  return negative;\n}\n\nlong strtol(const char *p, char **pp, int base) {\n  const char *orig = p;\n  bool neg = parse_sign(&p);\n  char digimax = '0' + (base <= 10 ? base : 10);\n  char hexmax = 'a' - 10 + base;\n  long result = 0;\n  const char *op = p;\n  for (;; ++p) {\n    char c = *p;\n    int n;\n    if ('0' <= c && c < digimax)\n      n = c - '0';\n    else {\n      c = tolower(c);\n      if ('a' <= c && c < hexmax)\n        n = c - 'a' + 10;\n      else\n        break;\n    }\n    result = result * base + n;\n  }\n  if (p == op)\n    p = orig;\n  if (neg)\n    result = -result;\n\n  if (pp != 0)\n    *pp = (char*)p;\n\n  return result;\n}\n\nunsigned long strtoul(const char *p, char **pp, int base) {\n  const char *orig = p;\n  if (*p == '+')\n    ++p;\n  char digimax = '0' + (base <= 10 ? base : 10);\n  char hexmax = 'a' - 10 + base;\n  unsigned long result = 0;\n  const char *op = p;\n  for (;; ++p) {\n    char c = *p;\n    int n;\n    if ('0' <= c && c < digimax)\n      n = c - '0';\n    else {\n      c = tolower(c);\n      if ('a' <= c && c < hexmax)\n        n = c - 'a' + 10;\n      else\n        break;\n    }\n    result = result * base + n;\n  }\n  if (p == op)\n    p = orig;\n\n  if (pp != 0)\n    *pp = (char*)p;\n\n  return result;\n}\n\n#ifndef __NO_FLONUM\nstatic double ipow(double base, long x) {\n  bool neg = false;\n  if (x < 0) {\n    neg = true;\n    x = -x;\n  }\n  double result = 1;\n  double a = base;\n  for (; x > 0; x >>= 1, a *= a) {\n    if ((x & 1) != 0)\n      result *= a;\n  }\n  return neg ? 1.0 / result : result;\n}\n\nstatic double strtod_i(const char *p, const char **pp) {\n  double result = 0;\n  for (;; ++p) {\n    char c = *p;\n    if (!(c >= '0' && c <= '9'))\n      break;\n    result = result * 10 + (c - '0');\n  }\n  *pp = p;\n  return result;\n}\n\ndouble strtod(const char* /*restrict*/ p, char ** /*restrict*/ pp) {\n  const char *orig = p;\n  bool neg = parse_sign(&p);\n\n  static const struct {\n    const char *str;\n    double pos, neg;\n  } CONST[] = {\n    {\"infinity\", 1.0 / 0.0, -1.0 / 0.0},\n    {\"inf\", 1.0 / 0.0, -1.0 / 0.0},\n    {\"nan\", 0.0 / 0.0, 0.0 / 0.0},\n  };\n  for (int i = 0, n = sizeof(CONST) / sizeof(*CONST); i < n; ++i) {\n    const char *str = CONST[i].str;\n    size_t len = strlen(str);\n    if (strncmp(p, str, len) == 0) {\n      p += len;\n      char c = *p;\n      if (pp != 0)\n        *pp = (char*)p;\n      return neg ? CONST[i].neg : CONST[i].pos;\n    }\n  }\n\n  const char *op = p;\n  double result = strtod_i(p, &p);\n  if (*p == '.') {\n    const char *q = p + 1;\n    double frac = strtod_i(q, &p);\n    result += frac * ipow(10, q - p);\n  }\n  if (*p == 'e' || *p == 'E') {\n    const char *q = p + 1;\n    bool neg2 = parse_sign(&q);\n    double order = strtod_i(q, &p);\n    if (q == p) {\n      // Error.\n    } else {\n      result *= ipow(10, neg2 ? -order : order);\n    }\n  }\n  if (p == op)\n    p = orig;\n  if (neg)\n    result = -result;\n\n  if (pp != 0)\n    *pp = (char*)p;\n\n  return result;\n}\n#endif\n\nstatic FILE _stdin = {.fd = STDIN_FILENO};\nstatic FILE _stdout = {.fd = STDOUT_FILENO};\nstatic FILE _stderr = {.fd = STDERR_FILENO};\nFILE *stdin = &_stdin;\nFILE *stdout = &_stdout;\nFILE *stderr = &_stderr;\n\nint fileno(FILE *fp) {\n  return fp->fd;\n}\n\nsize_t fwrite(const void *buffer, size_t size, size_t count, FILE *fp) {\n  return write(fp->fd, buffer, size * count);\n}\n\nsize_t fread(void *buffer, size_t size, size_t count, FILE *fp) {\n  return read(fp->fd, buffer, size * count);\n}\n\nint vfprintf(FILE *fp, const char *fmt, va_list ap) {\n  // TODO: directly output to fd, not use vsnprintf.\n  char buf[1024];\n  int len = vsnprintf(buf, sizeof(buf), fmt, ap);\n  return write(fileno(fp), buf, len);\n}\n\nint fprintf(FILE *fp, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  int len = vfprintf(fp, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\nint printf(const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  int len = vfprintf(stdout, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\nint atoi(const char *s) {\n  int n = 0;\n  for (; '0' <= *s && *s <= '9'; ++s)\n    n = n * 10 + (*s - '0');\n  return n;\n}\n\nvoid qsort(void *base, size_t nmemb, size_t size, int (*compare)(const void *, const void *)) {\n  if (nmemb <= 1)\n    return;\n\n  char *a = base;\n  const char *px;\n\n  px = &a[(nmemb >> 1) * size];\n  int i = 0;\n  int j = nmemb - 1;\n  for (;;) {\n    while (compare(&a[i * size], px) < 0)\n      ++i;\n    while (compare(px, &a[j * size]) < 0)\n      --j;\n    if (i >= j)\n      break;\n\n    char *pi = &a[i * size];\n    char *pj = &a[j * size];\n    for (size_t k = 0; k < size; ++k) {\n      char t = pi[k];\n      pi[k] = pj[k];\n      pj[k] = t;\n    }\n    if (px == pi)\n      px = pj;\n    else if (px == pj)\n      px = pi;\n    ++i;\n    --j;\n  }\n  if (i > 1)\n    qsort(a, i, size, compare);\n  if ((size_t)(j + 2) < nmemb)\n    qsort(&a[(j + 1) * size], nmemb - j - 1, size, compare);\n}\n\n//\n\nint isdigit(int c) {\n  return '0' <= c && c <= '9';\n}\n\nint isxdigit(int c) {\n  return ('0' <= c && c <= '9') || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f');\n}\n\nint isalpha(int c) {\n  return ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z');\n}\n\nint isalnum(int c) {\n  return isalpha(c) || isdigit(c);\n}\n\nint isspace(int c) {\n  return (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' ||\n          c == '\\f' || c == '\\v');\n}\n\nint tolower(int c) {\n  return ('A' <= c && c <= 'Z') ? c + ('a' - 'A') : c;\n}\n\nint toupper(int c) {\n  return ('a' <= c && c <= 'z') ? c - ('a' - 'A') : c;\n}\n\nchar *dirname(char *path) {\n  char *p = strrchr(path, '/');\n  if (p != NULL) {\n    *p = '\\0';\n    return path;\n  }\n  return \".\";\n}\n\nchar *basename(char *path) {\n  char *p = strrchr(path, '/');\n  if (p != NULL)\n    return p + 1;\n  else\n    return path;\n}\n\n//\n\nFILE *fopen(const char *fileName, const char *mode) {\n  static const struct {\n    const char *str;\n    int flag;\n  } kTable[] = {\n    {\"r\", O_RDONLY},\n    {\"w\", O_WRONLY | O_CREAT | O_TRUNC},\n    {\"a\", O_WRONLY | O_CREAT | O_APPEND},\n    {\"rb\", O_RDONLY},\n    {\"wb\", O_WRONLY | O_CREAT | O_TRUNC},\n    {\"ab\", O_WRONLY | O_CREAT | O_APPEND},\n    {\"r+\", O_RDONLY},\n    {\"w+\", O_WRONLY | O_CREAT},\n    {\"a+\", O_WRONLY | O_CREAT | O_APPEND},\n    {\"r+b\", O_RDONLY},\n    {\"w+b\", O_WRONLY | O_CREAT},\n    {\"a+b\", O_WRONLY | O_CREAT | O_APPEND},\n    {\"rb+\", O_RDONLY},\n    {\"wb+\", O_WRONLY | O_CREAT},\n    {\"ab+\", O_WRONLY | O_CREAT | O_APPEND},\n  };\n\n  int flag = -1;\n  for (int i = 0; i < sizeof(kTable) / sizeof(*kTable); ++i) {\n    if (strcmp(kTable[i].str, mode) == 0) {\n      flag = kTable[i].flag;\n      break;\n    }\n  }\n  if (flag == -1)\n    return NULL;\n\n  int mod = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n  int fd = open(fileName, flag, mod);\n  if (fd < 0) {\n    return NULL;\n  }\n\n  FILE *fp = malloc(sizeof(*fp));\n  if (fp == NULL) {\n    close(fd);\n    return NULL;\n  }\n\n  fp->fd = fd;\n  return fp;\n}\n\nint fclose(FILE *fp) {\n  if (fp == NULL || fp->fd < 0)\n    return EOF;\n  close(fp->fd);\n  fp->fd = -1;\n  free(fp);\n  return 0;\n}\n\nint fseek(FILE *fp, long offset, int origin) {\n  return lseek(fp->fd, offset, origin);\n}\n\nlong ftell(FILE *fp) {\n  return fseek(fp, 0, SEEK_CUR);\n}\n\nint fgetc(FILE *fp) {\n  unsigned char c;\n  int len = read(fp->fd, &c, 1);\n  return len == 1 ? c : EOF;\n}\n\nint fputc(int c, FILE *fp) {\n  unsigned char cc = c;\n  int len = write(fp->fd, &cc, 1);\n  return len == 1 ? c : EOF;\n}\n\nchar *getcwd(char *buffer, size_t size) {\n  void *allocated = NULL;\n  if (buffer == NULL) {\n    if (size == 0) {\n      size = 512;  // PATH_MAX\n    }\n    buffer = allocated = malloc(size + 1);\n    if (buffer == NULL)\n      return NULL;\n  }\n  int result = _getcwd(buffer, size);\n  if (result < 0) {\n    // errno = -result;\n    free(allocated);\n    return NULL;\n  }\n  return buffer;\n}\n\nFILE *tmpfile(void) {\n  int fd = _tmpfile();\n  if (fd < 0)\n    return NULL;\n\n  FILE *fp = malloc(sizeof(*fp));\n  if (fp == NULL) {\n    close(fd);\n    return NULL;\n  }\n\n  fp->fd = fd;\n  return fp;\n}\n\nstatic char *curbrk;\nint brk(void *addr) {\n  void *result = _brk(addr);\n  curbrk = result;\n  if (result < addr)\n    return EOF;\n  return 0;\n}\n\nvoid *sbrk(intptr_t increment) {\n  char *p = curbrk;\n  if (p == NULL)\n    p = _brk(NULL);\n  char *next = p + increment;\n  if (brk(next) < 0)\n    return (void*)-1;\n  return p;\n}\n\n#include \"ctype.h\"\n#include \"stdarg.h\"\n#include \"stdint.h\"  // uintptr_t\n#include \"stdio.h\"\n#include \"string.h\"\n\n#define NULL  ((void*)0)\n#define MIN(a, b)  ((a) < (b) ? (a) : (b))\n\nstatic char kHexDigits[] = \"0123456789abcdef\";\nstatic char kUpperHexDigits[] = \"0123456789ABCDEF\";\n\nstatic int\nputstr(char *out, int o, int n, const char *s)\n{\n  while (*s != '\\0' && o < n)\n    out[o++] = *s++;\n  return o;\n}\n\nstatic int\nputpadding(char *out, int o, int n, int m, char padding)\n{\n  if (m > n - o)\n    m = n - o;\n  for (; m > 0; --m)\n    out[o++] = padding;\n  return o;\n}\n\n// Output is not '\\0' terminated.\nstatic int\nsnprintuint(char *out, unsigned int n, unsigned int x,\n            int base, const char* digits, int order, int padding)\n{\n  char buf[16];\n  unsigned int i, o;\n\n  i = 0;\n  do{\n    buf[i++] = digits[x % base];\n    x /= base;\n  }while(x != 0);\n\n  if (i < order) {\n    memset(buf + i, padding, order - i);\n    i = order;\n  }\n\n  for (o = 0; i > 0 && o < n; ++o)\n    out[o] = buf[--i];\n\n  return o;\n}\n\nstatic int\nsnprintulong(char *out, unsigned int n, unsigned long x,\n             int base, const char* digits, int order, int padding)\n{\n  char buf[32];\n  unsigned int i, o;\n\n  i = 0;\n  do{\n    buf[i++] = digits[x % base];\n    x /= base;\n  }while(x != 0);\n\n  if (i < order) {\n    memset(buf + i, padding, order - i);\n    i = order;\n  }\n\n  for (o = 0; i > 0 && o < n; ++o)\n    out[o] = buf[--i];\n\n  return o;\n}\n\nstatic int\nsnprintstr(char *out, unsigned int n, const char* s,\n           int order, int suborder, int leftalign)\n{\n  int o = 0;\n  if(s == NULL)\n    s = \"(null)\";\n  size_t len = strlen(s);\n  if (suborder > 0)\n    len = MIN(len, suborder);\n  if (order <= 0 || len >= order) {\n    o = putstr(out, o, MIN(n, o + len), s);\n  } else {\n    if (leftalign) {\n      o = putstr(out, o, MIN(n, o + len), s);\n      o = putpadding(out, o, n, order - len, ' ');\n    } else {\n      o = putpadding(out, o, n, order - len, ' ');\n      o = putstr(out, o, MIN(n, o + len), s);\n    }\n  }\n  return o;\n}\n\nstatic int\nsprintsign(char *out, int negative, int force, int *porder)\n{\n  int o = 0;\n  if (negative) {\n    out[o++] = '-';\n  } else if (force) {\n    out[o++] = '+';\n  }\n  if (*porder > 1 && o > 0)\n    *porder -= o;\n  return o;\n}\n\n// Only understands %d, %x, %X, %p, %s, %c, %f and \"+-0~9\".\n// '\\0' is not put at the end if the buffer is smaller than output.\nint\nvsnprintf(char *out, size_t n, const char *fmt_, va_list ap)\n{\n  const unsigned char *fmt = (const unsigned char*)fmt_;\n  int c, i;\n  int o;\n\n  for(i = o = 0; fmt[i] != '\\0' && o < n; i++){\n    c = fmt[i];\n    if(c != '%'){\n      out[o++] = c;\n      continue;\n    }\n\n    // Handle '%'\n    char padding = ' ';\n    int order = 0, suborder = 0;\n    int sign = 0;\n    int leftalign = 0;\n    int bLong = 0;\n    c = fmt[++i];\n    if (c == '+') {\n      sign = 1;\n      c = fmt[++i];\n    } else if (c == '-') {\n      leftalign = 1;\n      c = fmt[++i];\n    }\n    if (c == '0') {\n      padding = '0';\n      c = fmt[++i];\n    }\n    if (c >= '1' && c <= '9') {\n      order = c - '0';\n      while (c = fmt[++i], c >= '0' && c <= '9')\n        order = order * 10 + (c - '0');\n    } else if (c == '*') {\n      order = va_arg(ap, int);\n    }\n    if (c == '.') {\n      c = fmt[++i];\n      if (isdigit(c)) {\n        do {\n          suborder = suborder * 10 + (c - '0');\n        } while (isdigit(c = fmt[++i]));\n      } else if (c == '*') {\n        suborder = va_arg(ap, int);\n        c = fmt[++i];\n      }\n    }\n\n    if(c == 'l'){\n      bLong = 1;\n      c = fmt[++i];\n    }\n    if(c == 'd'){\n      if (bLong) {\n        long x = va_arg(ap, long);\n        o += sprintsign(out + o, x < 0, sign, &order);\n        unsigned long ux = x < 0 ? -x : x;\n        o += snprintulong(out + o, n - o, ux, 10, kHexDigits, order, padding);\n      } else {\n        int x = va_arg(ap, int);\n        o += sprintsign(out + o, x < 0, sign, &order);\n        unsigned int ux = x < 0 ? -x : x;\n        o += snprintuint(out + o, n - o, ux, 10, kHexDigits, order, padding);\n      }\n    } else if(tolower(c) == 'x') {\n      const char *digits = c == 'x' ? kHexDigits : kUpperHexDigits;\n      if (bLong) {\n        long x = va_arg(ap, long);\n        o += snprintulong(out + o, n - o, x, 16, digits, order, padding);\n      } else {\n        int x = va_arg(ap, int);\n        o += snprintuint(out + o, n - o, x, 16, digits, order, padding);\n      }\n    } else if(c == 'p') {\n      void *ptr = va_arg(ap, void*);\n      order -= 2;\n      if (order < 0)\n        order = 0;\n      if (order == 0 || padding != ' ') {\n        o += snprintstr(out + o, n - o, \"0x\", 0, 0, 0);\n        o += snprintulong(out + o, n - o, (uintptr_t)ptr, 16, kHexDigits, order, padding);\n      } else {\n        char buf[32];\n        int oo = snprintulong(buf, sizeof(buf), (uintptr_t)ptr, 16, kHexDigits, 0, padding);\n        if (order > oo)\n          o = putpadding(out, o, n, order - oo, padding);\n        o += snprintstr(out + o, n - o, \"0x\", 0, 0, 0);\n        o += snprintstr(out + o, n - o, buf, 0, 0, 0);\n      }\n    } else if(c == 's'){\n      // (\"%5\", \"foo\")         = \"  foo\"\n      // (\"%-5\", \"foo\")        = \"foo  \"\n      // (\"%5\", \"foobarbaz\")   = \"foobarbaz\"\n      // (\"%.3\", \"foobarbaz\")  = \"foo\"\n      // (\"%5.7\", \"foobarbaz\") = \"foobarb\"\n      // (\"%5.3\", \"foobarbaz\") = \"  foo\"\n\n      const char *s = va_arg(ap, const char*);\n      o += snprintstr(out + o, n - o, s, order, suborder, leftalign);\n    } else if(c == 'c'){\n      out[o++] = va_arg(ap, unsigned int);\n    } else if(c == '%'){\n      out[o++] = c;\n    } else {\n      // Unknown % sequence.  Print it to draw attention.\n      out[o++] = '%';\n      if (o >= n)\n        break;\n      if (c != '\\0')\n        out[o++] = c;\n    }\n  }\n\n  if (o < n)\n    out[o] = '\\0';\n  return o;\n}\n\nint\nsnprintf(char *out, size_t n, const char *fmt, ...)\n{\n  va_list ap;\n  int len;\n  va_start(ap, fmt);\n  len = vsnprintf(out, n, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\nint\nsprintf(char *out, const char *fmt, ...)\n{\n  va_list ap;\n  int len;\n  va_start(ap, fmt);\n  len = vsnprintf(out, (size_t)-1, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"unistd.h\"  // for sbrk\n\n// Memory allocator by Kernighan and Ritchie,\n// The C programming Language, 2nd ed.  Section 8.7.\n\n#define PAGESIZE  (4096)\n\ntypedef long Align;\n\nunion header {\n  struct {\n    union header *ptr;\n    unsigned int size;\n  } s;\n  Align x;\n};\n\ntypedef union header Header;\n\nstatic Header base = {.s={.ptr=&base, .size=0}};\nstatic Header *freep = &base;\n\nvoid\nfree(void *ap)\n{\n  Header *bp, *p;\n\n  if (ap == 0)\n    return;\n\n  bp = (Header*)ap - 1;\n  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)\n    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))\n      break;\n  if(bp + bp->s.size == p->s.ptr){\n    bp->s.size += p->s.ptr->s.size;\n    bp->s.ptr = p->s.ptr->s.ptr;\n  } else\n    bp->s.ptr = p->s.ptr;\n  if(p + p->s.size == bp){\n    p->s.size += bp->s.size;\n    p->s.ptr = bp->s.ptr;\n  } else\n    p->s.ptr = bp;\n  freep = p;\n}\n\nstatic Header*\nmorecore(size_t nu)\n{\n  size_t size;\n  char *p;\n  Header *hp;\n\n  size = (nu * sizeof(Header) + (PAGESIZE - 1)) & -PAGESIZE;\n  p = sbrk(size);\n  if(p == (char*)-1)\n    return 0;\n  hp = (Header*)p;\n  hp->s.size = size / sizeof(Header);\n  free((void*)(hp + 1));\n  return freep;\n}\n\nvoid*\nmalloc(size_t nbytes)\n{\n  Header *p, *prevp;\n  size_t nunits;\n\n  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;\n  prevp = freep;\n  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){\n    if(p->s.size >= nunits){\n      if(p->s.size == nunits)\n        prevp->s.ptr = p->s.ptr;\n      else {\n        p->s.size -= nunits;\n        p += p->s.size;\n        p->s.size = nunits;\n      }\n      freep = prevp;\n      return (void*)(p + 1);\n    }\n    if(p == freep)\n      if((p = morecore(nunits)) == 0)\n        return 0;\n  }\n}\n\nvoid*\ncalloc(size_t nmemb, size_t size)\n{\n  size_t nbytes = nmemb * size;\n  void *adr = malloc(nbytes);\n  if (adr != NULL)\n    memset(adr, 0, nbytes);\n  return adr;\n}\n\nvoid*\nrealloc(void* p, size_t size)\n{\n  if (size <= 0) {\n    free(p);\n    return NULL;\n  }\n\n  if (p == NULL)\n    return malloc(size);\n\n  void* buf = malloc(size);\n  if (buf != NULL) {\n    Header* h = (Header*)p - 1;\n    size_t s = (h->s.size - 1) * sizeof(Header);\n    memcpy(buf, p, size > s ? s : size);\n    free(p);\n  }\n  return buf;\n}\n"}}}
